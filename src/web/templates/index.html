<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>EloquencÃ© FYP</title>
    <script src="{{ url_for('static', filename='speech.js') }}"></script>
    <link rel="stylesheet" href="{{ url_for('static', filename='chat.css') }}">
  </head>
  <body>
    <div class="container">
      <div id="chatScreen">
        <div class="header">
          <h1>Sales Assistant</h1>
          <div style="display: flex; gap: 12px; align-items: center">
            <a href="/knowledge" class="reset-btn" style="text-decoration: none"
              >Knowledge Base</a
            >
            <button class="reset-btn" onclick="resetChat()">Reset</button>
            <div class="status-container">
              <div class="status-item">
                <span class="status-label">Strategy:</span>
                <span class="status-value" id="strategyBadge">â€”</span>
              </div>
              <div class="status-item">
                <span class="status-label">Stage:</span>
                <span class="status-value" id="stageBadge">intent</span>
              </div>
            </div>
          </div>
        </div>

        <div class="chat-container" id="chatContainer"></div>

        <div class="input-area">
          <button
            class="mic-btn"
            id="micBtn"
            onclick="toggleMic()"
            title="Voice input"
          >
            ðŸŽ¤
          </button>
          <textarea
            id="messageInput"
            placeholder="Type your messageâ€¦ (Shift+Enter for new line)"
            onkeydown="handleKeyDown(event)"
            rows="1"
            autocomplete="off"
          ></textarea>
          <button class="send-btn" id="sendBtn" onclick="sendMessage()">
            Send
          </button>
        </div>
      </div>
    </div>

    <script>
      let isTyping = false,
        userTurnIndex = 0,
        sessionId = null;

      // â”€â”€â”€ Session â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      function getSessionId() {
        if (!sessionId) sessionId = localStorage.getItem("sessionId");
        return sessionId;
      }

      // â”€â”€â”€ localStorage history â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Maintains a mirror of the conversation for reload persistence.
      // Stored as [{role:"user"|"assistant", content:str}]
      let _cachedHistory = [];

      function saveHistoryToStorage() {
        localStorage.setItem("chatHistory", JSON.stringify(_cachedHistory));
      }

      function loadHistoryFromStorage() {
        try {
          return JSON.parse(localStorage.getItem("chatHistory") || "[]");
        } catch {
          return [];
        }
      }

      function clearStoredHistory() {
        _cachedHistory = [];
        localStorage.removeItem("chatHistory");
        localStorage.removeItem("chatStage");
        localStorage.removeItem("chatStrategy");
      }

      // â”€â”€â”€ Session Expiration Handler â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      function handleSessionExpired() {
        // Clear all stored data
        localStorage.removeItem("sessionId");
        clearStoredHistory();
        sessionId = null;

        // Clear the chat container
        const container = document.getElementById("chatContainer");
        container.innerHTML = "";

        // Add a notice
        const notice = document.createElement("div");
        notice.className = "edit-divider";
        notice.textContent = "Session expired â€” conversation has been reset";
        notice.style.color = "#d4a373";
        notice.style.marginBottom = "12px";
        container.appendChild(notice);

        // Reinitialize the chatbot
        initChatbot();
      }

      // If server reports session loss, clear client state and re-init
      function handleServerSessionError(data) {
        if (!data) return false;
        const err = data.error;
        if (err === "No active session" || err === "Session not found") {
          console.warn("Server lost session memory. Re-initializing...");
          localStorage.removeItem("sessionId"); // Clear ghost ID
          clearStoredHistory();
          sessionId = null;
          initChatbot();
          return true;
        }
        return false;
      }

      // â”€â”€â”€ TTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const tts = {
        speak: (t) =>
          "speechSynthesis" in window &&
          (speechSynthesis.cancel(),
          speechSynthesis.speak(new SpeechSynthesisUtterance(t)),
          true),
        stop: () => "speechSynthesis" in window && speechSynthesis.cancel(),
        isSpeaking: () =>
          "speechSynthesis" in window && speechSynthesis.speaking,
      };

      function parsePunctuation(text) {
        return text
          .replace(/ period /g, ". ")
          .replace(/ comma /g, ", ")
          .replace(/ question mark /g, "? ")
          .replace(/ new line /g, "\n");
      }

      // â”€â”€â”€ Message rendering â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      function createMessageElement(text, sender, msgIdx, metrics = null) {
        const msg = document.createElement("div");
        msg.className = `message ${sender}`;

        if (msgIdx !== null && msgIdx !== undefined) {
          msg.setAttribute("data-msg-idx", msgIdx);
        }

        const bubble = document.createElement("div");
        bubble.className = "message-bubble";
        // Preserve newlines as <br> in display
        const safeText = text || "";
        bubble.innerHTML = safeText
          .split("\n")
          .map((l) => {
            const s = document.createElement("span");
            s.textContent = l;
            return s.outerHTML;
          })
          .join("<br>");

        const actions = document.createElement("div");
        actions.className = "message-actions";

        if (sender === "bot") {
          const btn = Object.assign(document.createElement("button"), {
            className: "tts-btn",
            innerHTML: "ðŸ”Š",
            title: "Read aloud",
          });
          btn.onclick = () => {
            if (tts.isSpeaking()) {
              tts.stop();
              btn.classList.remove("speaking");
            } else {
              speechSynthesis.cancel();
              const utter = new SpeechSynthesisUtterance(text);
              btn.classList.add("speaking");
              utter.onend = () => btn.classList.remove("speaking");
              utter.onerror = () => btn.classList.remove("speaking");
              speechSynthesis.speak(utter);
            }
          };
          actions.appendChild(btn);
        } else {
          const btn = Object.assign(document.createElement("button"), {
            className: "edit-btn",
            innerHTML: "âœï¸ Edit",
          });
          btn.onclick = () => editMessage(msgIdx, text, msg);
          actions.appendChild(btn);
        }

        msg.appendChild(bubble);
        msg.appendChild(actions);

        if (metrics && sender === "bot") {
          const metricsDiv = document.createElement("div");
          metricsDiv.className = "message-metrics";
          let t = `${metrics.latency_ms.toFixed(1)}ms`;
          if (metrics.provider) t += ` â€¢ ${metrics.provider}`;
          if (metrics.input_length || metrics.output_length)
            t += ` â€¢ ${metrics.input_length}â†’${metrics.output_length}`;
          metricsDiv.textContent = t;
          msg.appendChild(metricsDiv);
        }

        return msg;
      }

      // â”€â”€â”€ Inline edit â†’ "string of 2 conversations" â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Clicking Edit replaces the bubble with an inline textarea.
      // On Save: grey out everything from the edited message onward,
      // insert a divider, then append the new branch below.
      function editMessage(msgIdx, originalText, msgEl) {
        const container = document.getElementById("chatContainer");

        // Swap bubble for inline editor
        const bubble = msgEl.querySelector(".message-bubble");
        const actions = msgEl.querySelector(".message-actions");
        bubble.style.display = "none";
        actions.style.display = "none";

        const ta = document.createElement("textarea");
        ta.className = "inline-edit-box";
        ta.value = originalText;

        const btnRow = document.createElement("div");
        btnRow.className = "inline-edit-actions";

        const saveBtn = document.createElement("button");
        saveBtn.className = "inline-save-btn";
        saveBtn.textContent = "Save";

        const cancelBtn = document.createElement("button");
        cancelBtn.className = "inline-cancel-btn";
        cancelBtn.textContent = "Cancel";

        btnRow.append(saveBtn, cancelBtn);
        msgEl.append(ta, btnRow);
        ta.focus();

        cancelBtn.onclick = () => {
          ta.remove();
          btnRow.remove();
          bubble.style.display = "";
          actions.style.display = "";
        };

        saveBtn.onclick = () => {
          const newText = ta.value.trim();
          if (!newText || newText === originalText) {
            cancelBtn.click();
            return;
          }
          if (newText.length > 1000) {
            alert("Message too long (max 1000 characters)");
            return;
          }

          // Disable edit UI while waiting
          saveBtn.disabled = true;
          cancelBtn.disabled = true;
          ta.disabled = true;

          // Grey out from edited message to end of container
          const allMsgs = [...container.children];
          const startIdx = allMsgs.indexOf(msgEl);
          for (let i = startIdx; i < allMsgs.length; i++) {
            allMsgs[i].classList.add("historical");
            allMsgs[i].removeAttribute("data-msg-idx");
          }

          // Recompute userTurnIndex = active (non-historical) user msgs
          userTurnIndex = container.querySelectorAll(
            ".message.user:not(.historical)",
          ).length;

          fetch("/api/edit", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "X-Session-ID": getSessionId(),
            },
            body: JSON.stringify({ index: msgIdx, message: newText }),
          })
            .then((r) => r.json())
            .then((data) => {
              if (!data.success) {
                // Check if session expired
                if (data.error === "Session not found") {
                  handleSessionExpired();
                  return;
                }

                // Undo greying
                allMsgs
                  .slice(startIdx)
                  .forEach((el) => el.classList.remove("historical"));
                userTurnIndex =
                  container.querySelectorAll(".message.user").length;
                ta.disabled = false;
                saveBtn.disabled = false;
                cancelBtn.disabled = false;
                alert("Edit failed: " + (data.error || "Unknown error"));
                return;
              }

              // Remove inline editor, restore hidden bubble (now historical)
              ta.remove();
              btnRow.remove();
              bubble.style.display = "";
              actions.style.display = "";

              // Insert visual divider
              const divider = document.createElement("div");
              divider.className = "edit-divider";
              divider.textContent = "Edited";
              container.appendChild(divider);

              // Append new branch: everything from edit point in returned history
              // data.history is the full new history; slice from msgIdx onward
              const newMsgs = data.history.slice(msgIdx);
              newMsgs.forEach((m, i) => {
                const role = m.role === "user" ? "user" : "bot";
                let metrics = null;
                if (
                  i === newMsgs.length - 1 &&
                  role === "bot" &&
                  data.latency_ms
                ) {
                  metrics = {
                    latency_ms: data.latency_ms,
                    provider: data.provider || "",
                    input_length: 0,
                    output_length: 0,
                  };
                }
                addMessage(m.content, role, metrics);
              });

              // Sync cached history with server truth
              _cachedHistory = data.history.map((m) => ({
                role: m.role,
                content: m.content,
              }));
              saveHistoryToStorage();

              updateStage(data.stage);
              if (data.strategy) updateStrategy(data.strategy);
            })
            .catch((e) => {
              allMsgs
                .slice(startIdx)
                .forEach((el) => el.classList.remove("historical"));
              ta.disabled = false;
              saveBtn.disabled = false;
              cancelBtn.disabled = false;
              alert("Edit error: " + e);
            });
        };
      }

      // â”€â”€â”€ Init / reload restoration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      function initChatbot() {
        const existingId = localStorage.getItem("sessionId");

        fetch("/api/init", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            session_id: existingId,
            // product_type and provider can be optionally sent here
            // They fall back to environment variables if not provided
          }),
        })
          .then((r) => r.json())
          .then((data) => {
            if (data.error) {
              alert("Error: " + data.error);
              return;
            }

            sessionId = data.session_id;
            localStorage.setItem("sessionId", sessionId);
            userTurnIndex = 0;

            if (data.history && data.history.length > 0) {
              // Server restored live session
              _cachedHistory = data.history.map((m) => ({
                role: m.role,
                content: m.content,
              }));
              saveHistoryToStorage();
              data.history.forEach((m) =>
                renderMessage(m.content, m.role === "user" ? "user" : "bot"),
              );
              updateStage(data.stage);
              if (data.strategy) updateStrategy(data.strategy);
            } else {
              // New session â€” check localStorage for visual restore
              const stored = loadHistoryFromStorage();
              if (stored.length > 0) {
                // Server has no live session (restarted), silently reconstruct
                _cachedHistory = stored;
                stored.forEach((m) =>
                  renderMessage(m.content, m.role === "user" ? "user" : "bot"),
                );
                const storedStage = localStorage.getItem("chatStage");
                if (storedStage) updateStage(storedStage);
                const storedStrategy = localStorage.getItem("chatStrategy");
                if (storedStrategy) updateStrategy(storedStrategy);

                // Rebuild server session silently (no user-facing message)
                fetch("/api/restore", {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    history: stored,
                  }),
                })
                  .then((r) => r.json())
                  .then((d) => {
                    if (d.success) {
                      sessionId = d.session_id;
                      localStorage.setItem("sessionId", sessionId);
                      // Stage/strategy already restored â€” no flicker
                    }
                  })
                  .catch((e) => {
                    // Restore failed â€” user needs to refresh to continue
                    console.error("Restore failed:", e);
                    const notice = document.createElement("div");
                    notice.className = "edit-divider";
                    notice.textContent =
                      "Connection issue â€” please refresh to continue";
                    notice.style.color = "#d4a373";
                    document
                      .getElementById("chatContainer")
                      .appendChild(notice);
                    document.getElementById("sendBtn").disabled = true;
                  });
              } else {
                addMessage(data.message, "bot");
                updateStage(data.stage);
              }
            }
          })
          .catch((error) => {
            alert("Error initializing chatbot: " + error);
          });
      }

      window.addEventListener("DOMContentLoaded", () => {
        initChatbot();
        const ta = document.getElementById("messageInput");
        ta.addEventListener("input", () => autoResizeTextarea(ta));
        speechRecognizer = new SpeechRecognizer();
      });

      // â”€â”€â”€ renderMessage â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Render-only (no cache side effects). Used during history restore.
      function renderMessage(text, sender) {
        const container = document.getElementById("chatContainer");
        let msgIdx = null;
        if (sender === "user") {
          msgIdx = userTurnIndex * 2;
          userTurnIndex += 1;
        }
        const el = createMessageElement(text, sender, msgIdx, null);
        container.appendChild(el);
        requestAnimationFrame(() => {
          container.scrollTop = container.scrollHeight;
        });
      }

      // â”€â”€â”€ addMessage â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      function addMessage(text, sender, metrics = null) {
        // Render to DOM first (without cache side effects)
        const container = document.getElementById("chatContainer");
        let msgIdx = null;
        if (sender === "user") {
          msgIdx = userTurnIndex * 2;
          userTurnIndex += 1;
        }

        const el = createMessageElement(text, sender, msgIdx, metrics);
        container.appendChild(el);
        requestAnimationFrame(() => {
          container.scrollTop = container.scrollHeight;
        });

        // Then update cache (unique to addMessage, not called during restore)
        if (sender === "user") {
          _cachedHistory.push({ role: "user", content: text });
          saveHistoryToStorage();
        } else {
          // Cache all bot responses (including initial greeting)
          _cachedHistory.push({ role: "assistant", content: text });
          saveHistoryToStorage();
          localStorage.setItem(
            "chatStage",
            document.getElementById("stageBadge").textContent,
          );
          localStorage.setItem(
            "chatStrategy",
            document.getElementById("strategyBadge").textContent,
          );
        }
      }

      // â”€â”€â”€ sendMessage â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      function sendMessage() {
        const input = document.getElementById("messageInput");
        const message = input.value.trim();
        if (!message || isTyping) return;

        addMessage(message, "user");
        input.value = "";
        autoResizeTextarea(input);
        showTyping();

        fetch("/api/chat", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-Session-ID": getSessionId(),
          },
          body: JSON.stringify({ message }),
        })
          .then((r) => r.json())
          .then((data) => {
            hideTyping();
            if (data.error) {
              // Check if session expired
              if (data.error === "Session not found") {
                handleSessionExpired();
                return;
              }
              addMessage("Error: " + data.error, "bot");
              return;
            }
            const metrics = {
              latency_ms: data.latency_ms || 0,
              provider: data.provider || "",
              input_length: data.metrics?.input_length || 0,
              output_length: data.metrics?.output_length || 0,
            };
            addMessage(data.message, "bot", metrics);
            updateStage(data.stage);
            if (data.strategy) updateStrategy(data.strategy);
          })
          .catch((error) => {
            hideTyping();
            addMessage("Error: " + error, "bot");
          });
      }

      // â”€â”€â”€ Typing indicator â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      function showTyping() {
        isTyping = true;
        const container = document.getElementById("chatContainer");
        const typingDiv = document.createElement("div");
        typingDiv.className = "message bot";
        typingDiv.id = "typingIndicator";
        const bubble = document.createElement("div");
        bubble.className = "message-bubble";
        const indicator = document.createElement("div");
        indicator.className = "typing-indicator";
        indicator.innerHTML = "<span></span><span></span><span></span>";
        bubble.appendChild(indicator);
        typingDiv.appendChild(bubble);
        container.appendChild(typingDiv);
        container.scrollTop = container.scrollHeight;
        document.getElementById("sendBtn").disabled = true;
      }

      function hideTyping() {
        isTyping = false;
        document.getElementById("typingIndicator")?.remove();
        document.getElementById("sendBtn").disabled = false;
      }

      // â”€â”€â”€ Badge helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      function updateStage(stage) {
        document.getElementById("stageBadge").textContent = stage.toUpperCase();
      }

      function updateStrategy(strategy) {
        document.getElementById("strategyBadge").textContent =
          strategy.toUpperCase();
      }

      // â”€â”€â”€ Textarea auto-resize â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      function autoResizeTextarea(el) {
        el.style.height = "auto";
        el.style.height = Math.min(el.scrollHeight, 120) + "px";
      }

      // â”€â”€â”€ Key handler â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Enter = send, Shift+Enter = newline (default textarea behaviour)
      function handleKeyDown(event) {
        if (event.key === "Enter" && !event.shiftKey) {
          event.preventDefault();
          sendMessage();
        }
        // Shift+Enter falls through â€” browser inserts newline naturally
      }

      // â”€â”€â”€ Reset â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      function resetChat() {
        if (!confirm("Reset conversation? This will clear all history."))
          return;

        fetch("/api/reset", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-Session-ID": getSessionId(),
          },
        })
          .then((r) => r.json())
          .then((data) => {
            if (data.success) {
              document.getElementById("chatContainer").innerHTML = "";
              userTurnIndex = 0;
              clearStoredHistory();
              localStorage.removeItem("sessionId");
              sessionId = null;
              updateStage("intent");
              updateStrategy("â€”");
              initChatbot();
            }
          })
          .catch((error) => alert("Error resetting chat: " + error));
      }

      // â”€â”€â”€ Speech module â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      let speechRecognizer;

      function toggleMic() {
        if (!speechRecognizer) {
          alert("Speech module loading...");
          return;
        }

        const input = document.getElementById("messageInput");
        const micBtn = document.getElementById("micBtn");

        if (speechRecognizer.getState()) {
          speechRecognizer.stop();
          return;
        }

        micBtn.classList.add("recording");
        micBtn.innerHTML = "â¹";
        let baseText = input.value;

        speechRecognizer.start(
          (text) => {
            baseText += parsePunctuation(text);
            input.value = baseText;
            autoResizeTextarea(input);
            input.focus();
          },
          (text) => {
            input.value = baseText + text;
          },
          () => {
            micBtn.classList.remove("recording");
            micBtn.innerHTML = "ðŸŽ¤";
            input.focus();
          },
          (err) => {
            console.warn("Mic Error:", err);
            micBtn.classList.remove("recording");
            micBtn.innerHTML = "ðŸŽ¤";
          },
        );
      }
    </script>
  </body>
</html>

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>EloquencÃ© FYP</title>
    <script src="{{ url_for('static', filename='speech.js') }}"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      html,
      body {
        height: 100%;
      }

      body {
        font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu,
          Cantarell, sans-serif;
        background: linear-gradient(135deg, #0b1220 0%, #071018 100%);
        display: flex;
        justify-content: center;
        align-items: stretch;
        padding: 20px;
        color: #dcd6c9;
        overflow: hidden;
      }

      .container {
        width: 100%;
        max-width: 800px;
        background: linear-gradient(
          180deg,
          rgba(12, 18, 28, 0.95),
          rgba(6, 10, 16, 0.95)
        );
        border-radius: 12px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6);
        overflow: hidden;
        display: flex;
        flex-direction: column;
        /* make container span the viewport height minus body padding */
        height: calc(100vh - 40px);
        min-height: 0;
      }

      .header {
        background: rgba(255, 255, 255, 0.02);
        color: #f3ecd7;
        padding: 18px 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: 1px solid rgba(255, 255, 255, 0.03);
      }

      .header h1 {
        font-size: 20px;
        font-weight: 600;
      }

      .status-container {
        display: flex;
        gap: 16px;
        align-items: center;
        font-size: 11px;
        color: #a39885;
      }

      .status-item {
        display: flex;
        gap: 6px;
        align-items: baseline;
      }

      .status-label {
        color: #7a736a;
        font-weight: 500;
      }

      .status-value {
        color: #d4c5a9;
        font-weight: 600;
        text-transform: capitalize;
      }

      .reset-btn {
        background: rgba(255, 255, 255, 0.03);
        color: #e6ddc8;
        border: 1px solid rgba(255, 255, 255, 0.1);
        padding: 6px 12px;
        border-radius: 8px;
        font-size: 12px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.15s;
      }

      .reset-btn:hover {
        background: rgba(183, 119, 31, 0.15);
        border-color: rgba(183, 119, 31, 0.3);
        color: #f7e9d1;
      }

      .chat-container {
        flex: 1 1 0;
        overflow-y: auto;
        padding: 20px;
        background: linear-gradient(
          180deg,
          rgba(6, 10, 16, 0.6),
          rgba(8, 12, 18, 0.6)
        );
        min-height: 0;
        scrollbar-width: thin;
        scrollbar-color: rgba(183, 119, 31, 0.6) rgba(255, 255, 255, 0.05);
      }

      .chat-container::-webkit-scrollbar {
        width: 10px;
      }

      .chat-container::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 5px;
        margin: 4px 0;
      }

      .chat-container::-webkit-scrollbar-thumb {
        background: rgba(183, 119, 31, 0.6);
        border-radius: 5px;
        border: 2px solid rgba(6, 10, 16, 0.6);
      }

      .chat-container::-webkit-scrollbar-thumb:hover {
        background: rgba(183, 119, 31, 0.8);
      }

      .chat-container::-webkit-scrollbar-thumb:active {
        background: #b7791f;
      }

      /* Scrollbar for textareas */
      textarea,
      .inline-edit-box {
        scrollbar-width: thin;
        scrollbar-color: rgba(183, 119, 31, 0.4) transparent;
      }
      textarea::-webkit-scrollbar,
      .inline-edit-box::-webkit-scrollbar {
        width: 6px;
      }
      textarea::-webkit-scrollbar-track,
      .inline-edit-box::-webkit-scrollbar-track {
        background: transparent;
      }
      textarea::-webkit-scrollbar-thumb,
      .inline-edit-box::-webkit-scrollbar-thumb {
        background: rgba(183, 119, 31, 0.4);
        border-radius: 3px;
      }
      textarea::-webkit-scrollbar-thumb:hover,
      .inline-edit-box::-webkit-scrollbar-thumb:hover {
        background: rgba(183, 119, 31, 0.6);
      }

      .message {
        display: flex;
        margin-bottom: 16px;
      }

      .message.user {
        justify-content: flex-end;
      }

      .message.bot {
        justify-content: flex-start;
      }

      .message-bubble {
        max-width: 70%;
        padding: 12px 16px;
        border-radius: 16px;
        font-size: 14px;
        line-height: 1.5;
        contain: layout paint;
      }

      .message.user .message-bubble {
        background: linear-gradient(180deg, #b7791f, #9a5f10);
        color: #071018;
        border-bottom-right-radius: 6px;
        box-shadow: 0 6px 18px rgba(151, 96, 30, 0.12);
      }

      .message.bot .message-bubble {
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.02),
          rgba(255, 255, 255, 0.03)
        );
        color: #e7dfcd;
        border: 1px solid rgba(255, 255, 255, 0.03);
        border-bottom-left-radius: 6px;
      }

      /* Latency/Metrics Badge */
      .message-metrics {
        font-size: 11px;
        color: #6b6460;
        margin-top: 4px;
        opacity: 0.65;
        font-weight: 400;
        letter-spacing: 0.3px;
      }

      .message.bot .message-metrics {
        margin-left: 4px;
      }

      .message.user .message-metrics {
        margin-right: 4px;
      }

      /* TTS Speaker Button */
      .tts-btn {
        background: transparent;
        border: none;
        color: #b7791f;
        cursor: pointer;
        padding: 4px 8px;
        font-size: 14px;
        opacity: 0.7;
        transition: opacity 0.15s;
      }
      .tts-btn:hover {
        opacity: 1;
      }
      .tts-btn.speaking {
        color: #4ade80;
      }

      /* Edit Button for User Messages */
      .edit-btn {
        background: transparent;
        border: none;
        color: #888;
        cursor: pointer;
        padding: 4px 8px;
        font-size: 12px;
        opacity: 0.6;
        transition: opacity 0.15s;
      }
      .edit-btn:hover {
        opacity: 1;
        color: #b7791f;
      }

      .message-actions {
        display: flex;
        gap: 4px;
        margin-top: 4px;
        justify-content: flex-end;
      }

      .typing-indicator {
        display: flex;
        gap: 4px;
        padding: 12px 16px;
      }

      .typing-indicator span {
        width: 8px;
        height: 8px;
        background: #b7791f;
        border-radius: 50%;
        opacity: 0.9;
        animation: typing 1.4s infinite;
      }

      .typing-indicator span:nth-child(2) {
        animation-delay: 0.2s;
      }

      .typing-indicator span:nth-child(3) {
        animation-delay: 0.4s;
      }

      @keyframes typing {
        0%,
        60%,
        100% {
          transform: translateY(0);
        }
        30% {
          transform: translateY(-10px);
        }
      }

      .input-area {
        padding: 16px;
        background: rgba(255, 255, 255, 0.01);
        border-top: 1px solid rgba(255, 255, 255, 0.02);
        display: flex;
        gap: 10px;
      }

      .input-area textarea {
        flex: 1;
        padding: 12px 16px;
        background: rgba(255, 255, 255, 0.02);
        color: #e6ddc8;
        border: 1px solid rgba(255, 255, 255, 0.03);
        border-radius: 8px;
        font-size: 14px;
        font-family: inherit;
        line-height: 1.5;
        resize: none;
        min-height: 44px;
        max-height: 120px;
        overflow-y: auto;
      }

      .input-area textarea:focus {
        outline: none;
        border-color: rgba(183, 119, 31, 0.18);
        box-shadow: 0 8px 20px rgba(15, 10, 6, 0.2);
      }

      .edit-divider {
        display: flex;
        align-items: center;
        gap: 8px;
        margin: 12px 0 8px;
        color: #6b6460;
        font-size: 11px;
        letter-spacing: 0.5px;
      }
      .edit-divider::before,
      .edit-divider::after {
        content: "";
        flex: 1;
        height: 1px;
        background: rgba(255, 255, 255, 0.06);
      }

      .message.historical {
        opacity: 0.3;
        filter: grayscale(0.5);
        pointer-events: none;
      }

      .inline-edit-box {
        width: 100%;
        padding: 8px 10px;
        background: rgba(255, 255, 255, 0.06);
        color: #e6ddc8;
        border: 1px solid #b7791f;
        border-radius: 8px;
        font-size: 14px;
        font-family: inherit;
        line-height: 1.4;
        resize: vertical;
        min-height: 56px;
        margin-top: 4px;
      }

      .inline-edit-actions {
        display: flex;
        gap: 6px;
        margin-top: 6px;
      }

      .inline-save-btn {
        background: #b7791f;
        color: #071018;
        border: none;
        padding: 5px 12px;
        border-radius: 6px;
        font-size: 12px;
        font-weight: 600;
        cursor: pointer;
      }

      .inline-cancel-btn {
        background: transparent;
        color: #888;
        border: 1px solid rgba(255, 255, 255, 0.15);
        padding: 5px 12px;
        border-radius: 6px;
        font-size: 12px;
        cursor: pointer;
      }

      .send-btn {
        background: #b7791f;
        color: #071018;
        border: none;
        padding: 12px 20px;
        border-radius: 8px;
        cursor: pointer;
        font-weight: 600;
        transition:
          background 0.15s,
          transform 0.06s;
      }

      .send-btn:hover {
        background: #9a5f10;
        transform: translateY(-1px);
      }

      .send-btn:disabled {
        background: #94a3b8;
        cursor: not-allowed;
      }

      .hidden {
        display: none;
      }

      .mic-btn {
        background: rgba(255, 255, 255, 0.05);
        color: #e6ddc8;
        border: 1px solid rgba(255, 255, 255, 0.1);
        padding: 12px 14px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 16px;
        transition: all 0.15s;
      }
      .mic-btn:hover {
        background: rgba(255, 255, 255, 0.1);
      }
      .mic-btn.recording {
        background: #dc2626;
        color: white;
        border-color: #dc2626;
        animation: pulse 1s infinite;
      }
      @keyframes pulse {
        50% {
          opacity: 0.7;
        }
      }

      #chatScreen {
        display: flex;
        flex-direction: column;
        height: 100%;
        min-height: 0;
      }

      /* Mobile Phone Compatibility */
      @media (max-width: 640px) {
        body {
          padding: 0;
        }

        .container {
          height: 100vh;
          height: 100dvh; /* accounts for mobile browser UI */
          border-radius: 0;
          box-shadow: none;
        }

        .header {
          flex-direction: column;
          align-items: flex-start;
          gap: 12px;
          padding: 16px;
        }

        .header > div {
          flex-wrap: wrap;
          justify-content: flex-start;
        }

        .status-container {
          width: 100%;
          justify-content: flex-start;
        }

        .message-bubble {
          max-width: 90%;
        }

        .input-area {
          padding: 12px;
          padding-bottom: max(12px, env(safe-area-inset-bottom));
          gap: 8px;
        }

        .mic-btn,
        .send-btn {
          padding: 10px 14px;
        }

        #messageInput {
          font-size: 16px; /* iOS requires 16px input fonts to prevent zoom focus */
          padding: 10px 14px;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div id="chatScreen">
        <div class="header">
          <h1>Sales Assistant</h1>
          <div style="display: flex; gap: 12px; align-items: center">
            <a href="/knowledge" class="reset-btn" style="text-decoration: none"
              >Knowledge Base</a
            >
            <button class="reset-btn" onclick="resetChat()">Reset</button>
            <div class="status-container">
              <div class="status-item">
                <span class="status-label">Strategy:</span>
                <span class="status-value" id="strategyBadge">â€”</span>
              </div>
              <div class="status-item">
                <span class="status-label">Stage:</span>
                <span class="status-value" id="stageBadge">intent</span>
              </div>
            </div>
          </div>
        </div>

        <div class="chat-container" id="chatContainer"></div>

        <div class="input-area">
          <button
            class="mic-btn"
            id="micBtn"
            onclick="toggleMic()"
            title="Voice input"
          >
            ðŸŽ¤
          </button>
          <textarea
            id="messageInput"
            placeholder="Type your messageâ€¦ (Shift+Enter for new line)"
            onkeydown="handleKeyDown(event)"
            rows="1"
            autocomplete="off"
          ></textarea>
          <button class="send-btn" id="sendBtn" onclick="sendMessage()">
            Send
          </button>
        </div>
      </div>
    </div>

    <script>
      let isTyping = false,
        userTurnIndex = 0,
        sessionId = null;

      // â”€â”€â”€ Session â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      function getSessionId() {
        if (!sessionId) sessionId = localStorage.getItem("sessionId");
        return sessionId;
      }

      // â”€â”€â”€ localStorage history â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Maintains a mirror of the conversation for reload persistence.
      // Stored as [{role:"user"|"assistant", content:str}]
      let _cachedHistory = [];

      function saveHistoryToStorage() {
        localStorage.setItem("chatHistory", JSON.stringify(_cachedHistory));
      }

      function loadHistoryFromStorage() {
        try {
          return JSON.parse(localStorage.getItem("chatHistory") || "[]");
        } catch {
          return [];
        }
      }

      function clearStoredHistory() {
        _cachedHistory = [];
        localStorage.removeItem("chatHistory");
        localStorage.removeItem("chatStage");
        localStorage.removeItem("chatStrategy");
      }

      // â”€â”€â”€ Session Expiration Handler â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      function handleSessionExpired() {
        // Clear all stored data
        localStorage.removeItem("sessionId");
        clearStoredHistory();
        sessionId = null;

        // Clear the chat container
        const container = document.getElementById("chatContainer");
        container.innerHTML = "";

        // Add a notice
        const notice = document.createElement("div");
        notice.className = "edit-divider";
        notice.textContent = "Session expired â€” conversation has been reset";
        notice.style.color = "#d4a373";
        notice.style.marginBottom = "12px";
        container.appendChild(notice);

        // Reinitialize the chatbot
        initChatbot();
      }

      // If server reports session loss, clear client state and re-init
      function handleServerSessionError(data) {
        if (!data) return false;
        const err = data.error;
        if (err === "No active session" || err === "Session not found") {
          console.warn("Server lost session memory. Re-initializing...");
          localStorage.removeItem("sessionId"); // Clear ghost ID
          clearStoredHistory();
          sessionId = null;
          initChatbot();
          return true;
        }
        return false;
      }

      // â”€â”€â”€ TTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const tts = {
        speak: (t) =>
          "speechSynthesis" in window &&
          (speechSynthesis.cancel(),
          speechSynthesis.speak(new SpeechSynthesisUtterance(t)),
          true),
        stop: () => "speechSynthesis" in window && speechSynthesis.cancel(),
        isSpeaking: () =>
          "speechSynthesis" in window && speechSynthesis.speaking,
      };

      function parsePunctuation(text) {
        return text
          .replace(/ period /g, ". ")
          .replace(/ comma /g, ", ")
          .replace(/ question mark /g, "? ")
          .replace(/ new line /g, "\n");
      }

      // â”€â”€â”€ Message rendering â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      function createMessageElement(text, sender, msgIdx, metrics = null) {
        const msg = document.createElement("div");
        msg.className = `message ${sender}`;

        if (msgIdx !== null && msgIdx !== undefined) {
          msg.setAttribute("data-msg-idx", msgIdx);
        }

        const bubble = document.createElement("div");
        bubble.className = "message-bubble";
        // Preserve newlines as <br> in display
        const safeText = text || "";
        bubble.innerHTML = safeText
          .split("\n")
          .map((l) => {
            const s = document.createElement("span");
            s.textContent = l;
            return s.outerHTML;
          })
          .join("<br>");

        const actions = document.createElement("div");
        actions.className = "message-actions";

        if (sender === "bot") {
          const btn = Object.assign(document.createElement("button"), {
            className: "tts-btn",
            innerHTML: "ðŸ”Š",
            title: "Read aloud",
          });
          btn.onclick = () => {
            if (tts.isSpeaking()) {
              tts.stop();
              btn.classList.remove("speaking");
            } else {
              speechSynthesis.cancel();
              const utter = new SpeechSynthesisUtterance(text);
              btn.classList.add("speaking");
              utter.onend = () => btn.classList.remove("speaking");
              utter.onerror = () => btn.classList.remove("speaking");
              speechSynthesis.speak(utter);
            }
          };
          actions.appendChild(btn);
        } else {
          const btn = Object.assign(document.createElement("button"), {
            className: "edit-btn",
            innerHTML: "âœï¸ Edit",
          });
          btn.onclick = () => editMessage(msgIdx, text, msg);
          actions.appendChild(btn);
        }

        msg.appendChild(bubble);
        msg.appendChild(actions);

        if (metrics && sender === "bot") {
          const metricsDiv = document.createElement("div");
          metricsDiv.className = "message-metrics";
          let t = `${metrics.latency_ms.toFixed(1)}ms`;
          if (metrics.provider) t += ` â€¢ ${metrics.provider}`;
          if (metrics.input_length || metrics.output_length)
            t += ` â€¢ ${metrics.input_length}â†’${metrics.output_length}`;
          metricsDiv.textContent = t;
          msg.appendChild(metricsDiv);
        }

        return msg;
      }

      // â”€â”€â”€ Inline edit â†’ "string of 2 conversations" â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Clicking Edit replaces the bubble with an inline textarea.
      // On Save: grey out everything from the edited message onward,
      // insert a divider, then append the new branch below.
      function editMessage(msgIdx, originalText, msgEl) {
        const container = document.getElementById("chatContainer");

        // Swap bubble for inline editor
        const bubble = msgEl.querySelector(".message-bubble");
        const actions = msgEl.querySelector(".message-actions");
        bubble.style.display = "none";
        actions.style.display = "none";

        const ta = document.createElement("textarea");
        ta.className = "inline-edit-box";
        ta.value = originalText;

        const btnRow = document.createElement("div");
        btnRow.className = "inline-edit-actions";

        const saveBtn = document.createElement("button");
        saveBtn.className = "inline-save-btn";
        saveBtn.textContent = "Save";

        const cancelBtn = document.createElement("button");
        cancelBtn.className = "inline-cancel-btn";
        cancelBtn.textContent = "Cancel";

        btnRow.append(saveBtn, cancelBtn);
        msgEl.append(ta, btnRow);
        ta.focus();

        cancelBtn.onclick = () => {
          ta.remove();
          btnRow.remove();
          bubble.style.display = "";
          actions.style.display = "";
        };

        saveBtn.onclick = () => {
          const newText = ta.value.trim();
          if (!newText || newText === originalText) {
            cancelBtn.click();
            return;
          }
          if (newText.length > 1000) {
            alert("Message too long (max 1000 characters)");
            return;
          }

          // Disable edit UI while waiting
          saveBtn.disabled = true;
          cancelBtn.disabled = true;
          ta.disabled = true;

          // Grey out from edited message to end of container
          const allMsgs = [...container.children];
          const startIdx = allMsgs.indexOf(msgEl);
          for (let i = startIdx; i < allMsgs.length; i++) {
            allMsgs[i].classList.add("historical");
            allMsgs[i].removeAttribute("data-msg-idx");
          }

          // Recompute userTurnIndex = active (non-historical) user msgs
          userTurnIndex = container.querySelectorAll(
            ".message.user:not(.historical)",
          ).length;

          fetch("/api/edit", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "X-Session-ID": getSessionId(),
            },
            body: JSON.stringify({ index: msgIdx, message: newText }),
          })
            .then((r) => r.json())
            .then((data) => {
              if (!data.success) {
                // Check if session expired
                if (data.error === "Session not found") {
                  handleSessionExpired();
                  return;
                }

                // Undo greying
                allMsgs
                  .slice(startIdx)
                  .forEach((el) => el.classList.remove("historical"));
                userTurnIndex =
                  container.querySelectorAll(".message.user").length;
                ta.disabled = false;
                saveBtn.disabled = false;
                cancelBtn.disabled = false;
                alert("Edit failed: " + (data.error || "Unknown error"));
                return;
              }

              // Remove inline editor, restore hidden bubble (now historical)
              ta.remove();
              btnRow.remove();
              bubble.style.display = "";
              actions.style.display = "";

              // Insert visual divider
              const divider = document.createElement("div");
              divider.className = "edit-divider";
              divider.textContent = "Edited";
              container.appendChild(divider);

              // Append new branch: everything from edit point in returned history
              // data.history is the full new history; slice from msgIdx onward
              const newMsgs = data.history.slice(msgIdx);
              newMsgs.forEach((m, i) => {
                const role = m.role === "user" ? "user" : "bot";
                let metrics = null;
                if (
                  i === newMsgs.length - 1 &&
                  role === "bot" &&
                  data.latency_ms
                ) {
                  metrics = {
                    latency_ms: data.latency_ms,
                    provider: data.provider || "",
                    input_length: 0,
                    output_length: 0,
                  };
                }
                addMessage(m.content, role, metrics);
              });

              // Sync cached history with server truth
              _cachedHistory = data.history.map((m) => ({
                role: m.role,
                content: m.content,
              }));
              saveHistoryToStorage();

              updateStage(data.stage);
              if (data.strategy) updateStrategy(data.strategy);
            })
            .catch((e) => {
              allMsgs
                .slice(startIdx)
                .forEach((el) => el.classList.remove("historical"));
              ta.disabled = false;
              saveBtn.disabled = false;
              cancelBtn.disabled = false;
              alert("Edit error: " + e);
            });
        };
      }

      // â”€â”€â”€ Init / reload restoration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      function initChatbot() {
        const existingId = localStorage.getItem("sessionId");

        fetch("/api/init", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            session_id: existingId,
            // product_type and provider can be optionally sent here
            // They fall back to environment variables if not provided
          }),
        })
          .then((r) => r.json())
          .then((data) => {
            if (data.error) {
              alert("Error: " + data.error);
              return;
            }

            sessionId = data.session_id;
            localStorage.setItem("sessionId", sessionId);
            userTurnIndex = 0;

            if (data.history && data.history.length > 0) {
              // Server restored live session
              _cachedHistory = data.history.map((m) => ({
                role: m.role,
                content: m.content,
              }));
              saveHistoryToStorage();
              data.history.forEach((m) =>
                renderMessage(m.content, m.role === "user" ? "user" : "bot"),
              );
              updateStage(data.stage);
              if (data.strategy) updateStrategy(data.strategy);
            } else {
              // New session â€” check localStorage for visual restore
              const stored = loadHistoryFromStorage();
              if (stored.length > 0) {
                // Server has no live session (restarted), silently reconstruct
                _cachedHistory = stored;
                stored.forEach((m) =>
                  renderMessage(m.content, m.role === "user" ? "user" : "bot"),
                );
                const storedStage = localStorage.getItem("chatStage");
                if (storedStage) updateStage(storedStage);
                const storedStrategy = localStorage.getItem("chatStrategy");
                if (storedStrategy) updateStrategy(storedStrategy);

                // Rebuild server session silently (no user-facing message)
                fetch("/api/restore", {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    history: stored,
                  }),
                })
                  .then((r) => r.json())
                  .then((d) => {
                    if (d.success) {
                      sessionId = d.session_id;
                      localStorage.setItem("sessionId", sessionId);
                      // Stage/strategy already restored â€” no flicker
                    }
                  })
                  .catch((e) => {
                    // Restore failed â€” user needs to refresh to continue
                    console.error("Restore failed:", e);
                    const notice = document.createElement("div");
                    notice.className = "edit-divider";
                    notice.textContent =
                      "Connection issue â€” please refresh to continue";
                    notice.style.color = "#d4a373";
                    document
                      .getElementById("chatContainer")
                      .appendChild(notice);
                    document.getElementById("sendBtn").disabled = true;
                  });
              } else {
                addMessage(data.message, "bot");
                updateStage(data.stage);
              }
            }
          })
          .catch((error) => {
            alert("Error initializing chatbot: " + error);
          });
      }

      window.addEventListener("DOMContentLoaded", () => {
        initChatbot();
        const ta = document.getElementById("messageInput");
        ta.addEventListener("input", () => autoResizeTextarea(ta));
        speechRecognizer = new SpeechRecognizer();
      });

      // â”€â”€â”€ renderMessage â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Render-only (no cache side effects). Used during history restore.
      function renderMessage(text, sender) {
        const container = document.getElementById("chatContainer");
        let msgIdx = null;
        if (sender === "user") {
          msgIdx = userTurnIndex * 2;
          userTurnIndex += 1;
        }
        const el = createMessageElement(text, sender, msgIdx, null);
        container.appendChild(el);
        requestAnimationFrame(() => {
          container.scrollTop = container.scrollHeight;
        });
      }

      // â”€â”€â”€ addMessage â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      function addMessage(text, sender, metrics = null) {
        // Render to DOM first (without cache side effects)
        const container = document.getElementById("chatContainer");
        let msgIdx = null;
        if (sender === "user") {
          msgIdx = userTurnIndex * 2;
          userTurnIndex += 1;
        }

        const el = createMessageElement(text, sender, msgIdx, metrics);
        container.appendChild(el);
        requestAnimationFrame(() => {
          container.scrollTop = container.scrollHeight;
        });

        // Then update cache (unique to addMessage, not called during restore)
        if (sender === "user") {
          _cachedHistory.push({ role: "user", content: text });
          saveHistoryToStorage();
        } else {
          // Cache all bot responses (including initial greeting)
          _cachedHistory.push({ role: "assistant", content: text });
          saveHistoryToStorage();
          localStorage.setItem(
            "chatStage",
            document.getElementById("stageBadge").textContent,
          );
          localStorage.setItem(
            "chatStrategy",
            document.getElementById("strategyBadge").textContent,
          );
        }
      }

      // â”€â”€â”€ sendMessage â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      function sendMessage() {
        const input = document.getElementById("messageInput");
        const message = input.value.trim();
        if (!message || isTyping) return;

        addMessage(message, "user");
        input.value = "";
        autoResizeTextarea(input);
        showTyping();

        fetch("/api/chat", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-Session-ID": getSessionId(),
          },
          body: JSON.stringify({ message }),
        })
          .then((r) => r.json())
          .then((data) => {
            hideTyping();
            if (data.error) {
              // Check if session expired
              if (data.error === "Session not found") {
                handleSessionExpired();
                return;
              }
              addMessage("Error: " + data.error, "bot");
              return;
            }
            const metrics = {
              latency_ms: data.latency_ms || 0,
              provider: data.provider || "",
              input_length: data.metrics?.input_length || 0,
              output_length: data.metrics?.output_length || 0,
            };
            addMessage(data.message, "bot", metrics);
            updateStage(data.stage);
            if (data.strategy) updateStrategy(data.strategy);
          })
          .catch((error) => {
            hideTyping();
            addMessage("Error: " + error, "bot");
          });
      }

      // â”€â”€â”€ Typing indicator â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      function showTyping() {
        isTyping = true;
        const container = document.getElementById("chatContainer");
        const typingDiv = document.createElement("div");
        typingDiv.className = "message bot";
        typingDiv.id = "typingIndicator";
        const bubble = document.createElement("div");
        bubble.className = "message-bubble";
        const indicator = document.createElement("div");
        indicator.className = "typing-indicator";
        indicator.innerHTML = "<span></span><span></span><span></span>";
        bubble.appendChild(indicator);
        typingDiv.appendChild(bubble);
        container.appendChild(typingDiv);
        container.scrollTop = container.scrollHeight;
        document.getElementById("sendBtn").disabled = true;
      }

      function hideTyping() {
        isTyping = false;
        document.getElementById("typingIndicator")?.remove();
        document.getElementById("sendBtn").disabled = false;
      }

      // â”€â”€â”€ Badge helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      function updateStage(stage) {
        document.getElementById("stageBadge").textContent = stage.toUpperCase();
      }

      function updateStrategy(strategy) {
        document.getElementById("strategyBadge").textContent =
          strategy.toUpperCase();
      }

      // â”€â”€â”€ Textarea auto-resize â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      function autoResizeTextarea(el) {
        el.style.height = "auto";
        el.style.height = Math.min(el.scrollHeight, 120) + "px";
      }

      // â”€â”€â”€ Key handler â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Enter = send, Shift+Enter = newline (default textarea behaviour)
      function handleKeyDown(event) {
        if (event.key === "Enter" && !event.shiftKey) {
          event.preventDefault();
          sendMessage();
        }
        // Shift+Enter falls through â€” browser inserts newline naturally
      }

      // â”€â”€â”€ Reset â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      function resetChat() {
        if (!confirm("Reset conversation? This will clear all history."))
          return;

        fetch("/api/reset", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-Session-ID": getSessionId(),
          },
        })
          .then((r) => r.json())
          .then((data) => {
            if (data.success) {
              document.getElementById("chatContainer").innerHTML = "";
              userTurnIndex = 0;
              clearStoredHistory();
              localStorage.removeItem("sessionId");
              sessionId = null;
              updateStage("intent");
              updateStrategy("â€”");
              initChatbot();
            }
          })
          .catch((error) => alert("Error resetting chat: " + error));
      }

      // â”€â”€â”€ Speech module â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      let speechRecognizer;

      function toggleMic() {
        if (!speechRecognizer) {
          alert("Speech module loading...");
          return;
        }

        const input = document.getElementById("messageInput");
        const micBtn = document.getElementById("micBtn");

        if (speechRecognizer.getState()) {
          speechRecognizer.stop();
          return;
        }

        micBtn.classList.add("recording");
        micBtn.innerHTML = "â¹";
        let baseText = input.value;

        speechRecognizer.start(
          (text) => {
            baseText += parsePunctuation(text);
            input.value = baseText;
            autoResizeTextarea(input);
            input.focus();
          },
          (text) => {
            input.value = baseText + text;
          },
          () => {
            micBtn.classList.remove("recording");
            micBtn.innerHTML = "ðŸŽ¤";
            input.focus();
          },
          (err) => {
            console.warn("Mic Error:", err);
            micBtn.classList.remove("recording");
            micBtn.innerHTML = "ðŸŽ¤";
          },
        );
      }
    </script>
  </body>
</html>
